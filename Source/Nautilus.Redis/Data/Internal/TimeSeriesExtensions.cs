// <auto-generated/>

using System;
using System.Collections.Generic;
using NRedisTimeSeries.Commands;
using NRedisTimeSeries.DataTypes;
using StackExchange.Redis;

namespace Nautilus.Redis.Data.Internal
{
    internal static class TimeSeriesExtensions
    {
        /// <summary>
        /// Query a range.
        /// </summary>
        /// <param name="db">StackExchange.Redis IDatabase instance</param>
        /// <param name="key">Key name for time series</param>
        /// <param name="fromTimeStamp">Start timestamp for the range query. "-" can be used to express the minimum possible timestamp.</param>
        /// <param name="toTimeStamp">End timestamp for range query, + can be used to express the maximum possible timestamp.</param>
        /// <param name="count">Optional: Returned list size.</param>
        /// <param name="aggregation">Optional: Aggregation type</param>
        /// <param name="timeBucket">Optional: Time bucket for aggregation in milliseconds</param>
        /// <returns>A list of TimeSeriesTuple</returns>
        public static IReadOnlyList<TimeSeriesTuple> TimeSeriesRevRange(
            this IDatabase db,
            string key,
            TimeStamp fromTimeStamp,
            TimeStamp toTimeStamp,
            long? count,
            Aggregation aggregation,
            long? timeBucket)
        {
            var args = new List<object>
                { key, fromTimeStamp.Value, toTimeStamp.Value };
            args.AddCount(count);
            args.AddAggregation(aggregation, timeBucket);
            return ParseTimeSeriesTupleArray(db.Execute("TS.REVRANGE", args));
        }

        private static TimeStamp ParseTimeStamp(RedisResult result)
        {
            if (result.Type == ResultType.None) return null;
            return new TimeStamp((long)result);
        }

        private static TimeSeriesTuple ParseTimeSeriesTuple(RedisResult result)
        {
            RedisResult[] redisResults = (RedisResult[])result;
            if (redisResults.Length == 0) return null;
            return new TimeSeriesTuple(ParseTimeStamp(redisResults[0]), (double)redisResults[1]);
        }

        private static IReadOnlyList<TimeSeriesTuple> ParseTimeSeriesTupleArray(RedisResult result)
        {
            RedisResult[] redisResults = (RedisResult[])result;
            var list = new List<TimeSeriesTuple>(redisResults.Length);
            if (redisResults.Length == 0) return list;
            Array.ForEach(redisResults, tuple => list.Add(ParseTimeSeriesTuple(tuple)));
            return list;
        }

        private static void AddCount(this IList<object> args, long? count)
        {
            if (count.HasValue)
            {
                args.Add("COUNT");
                args.Add(count.Value);
            }
        }

        private static void AddAggregation(this IList<object> args, Aggregation aggregation, long? timeBucket)
        {
            if(aggregation != null)
            {
                args.Add("AGGREGATION");
                args.Add(aggregation.Name);
                if (!timeBucket.HasValue)
                {
                    throw new ArgumentException("RANGE Aggregation should have timeBucket value");
                }
                args.Add(timeBucket.Value);
            }
        }
    }
}
